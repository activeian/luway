rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Utility functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(resource) {
      return request.auth.uid == resource.data.userId;
    }
    
    function isValidUser() {
      return isAuthenticated() && 
             request.auth.token.email_verified == true;
    }
    
    function hasAdminRole() {
      return request.auth.token.admin == true;
    }
    
    // Users collection
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
                       request.auth.uid == userId &&
                       validateUserData();
      allow update: if isAuthenticated() && 
                       request.auth.uid == userId &&
                       validateUserData();
      allow delete: if isAuthenticated() && 
                       request.auth.uid == userId;
      
      function validateUserData() {
        let data = request.resource.data;
        let hasRequiredFields = data.keys().hasAll(['displayName', 'email', 'createdAt']) &&
               data.displayName is string &&
               data.displayName.size() >= 2 &&
               data.displayName.size() <= 50 &&
               data.email is string &&
               data.email.matches('.*@.*\\..*') &&
               data.createdAt is timestamp;
        
        // Validări opționale pentru notificări
        let hasValidOptionalFields = 
               (!data.keys().hasAny(['fcmToken']) || data.fcmToken is string) &&
               (!data.keys().hasAny(['nickname']) || (data.nickname is string && data.nickname.size() <= 30)) &&
               (!data.keys().hasAny(['isOnline']) || data.isOnline is bool) &&
               (!data.keys().hasAny(['lastSeen']) || data.lastSeen is timestamp);
        
        return hasRequiredFields && hasValidOptionalFields;
      }
      
      // User favorites subcollection
      match /favorites/{favoriteId} {
        allow read, write: if isAuthenticated() && 
                             request.auth.uid == userId;
      }

      // User notifications subcollection
      match /notifications/{notificationId} {
        allow read: if isAuthenticated() && 
                       request.auth.uid == userId;
        allow write: if isAuthenticated() && 
                        request.auth.uid == userId;
        allow create: if true; // Allow server to create notifications
        allow update: if isAuthenticated() && 
                         request.auth.uid == userId &&
                         validateNotificationUpdate();
        allow delete: if isAuthenticated() && 
                         request.auth.uid == userId;

        function validateNotificationUpdate() {
          // Doar permite actualizarea câmpului 'read'
          return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
        }
      }
      
      // User behavior subcollection
      match /behavior/{behaviorType} {
        allow read, write: if isAuthenticated() && 
                             request.auth.uid == userId;
        
        // Behavior items subcollections
        match /{subcollection}/{docId} {
          allow read, write: if isAuthenticated() && 
                               request.auth.uid == userId;
        }
      }
      
      // User blocked users subcollection
      match /blocked_users/{blockedUserId} {
        // Users can read/write their own blocked list
        allow read, write: if isAuthenticated() && 
                             request.auth.uid == userId;
        // Allow others to read if they are checking if they are blocked by this user
        allow read: if isAuthenticated() && 
                       request.auth.uid == blockedUserId;
      }
      
      // User chat settings subcollection
      match /chat_settings/{settingId} {
        allow read, write: if isAuthenticated() && 
                             request.auth.uid == userId;
      }
    }
    
    // Vehicles collection
    match /vehicles/{vehicleId} {
      allow read: if true; // Public read access for browsing
      allow create: if isValidUser() &&
                       validateVehicleData() &&
                       checkVehicleLimit();
      allow update: if isValidUser() && 
                       isOwner(resource) &&
                       validateVehicleData();
      allow delete: if isValidUser() && 
                       isOwner(resource);
      
      function validateVehicleData() {
        let data = request.resource.data;
        return data.keys().hasAll([
          'title', 'description', 'price', 'currency', 
          'brand', 'model', 'year', 'fuelType', 
          'transmission', 'condition', 'category',
          'country', 'licensePlate', 'userId', 'createdAt'
        ]) &&
        data.title is string &&
        data.title.size() >= 5 &&
        data.title.size() <= 100 &&
        data.description is string &&
        data.description.size() <= 1000 &&
        data.price is number &&
        data.price >= 1 &&
        data.price <= 10000000 &&
        data.currency is string &&
        data.currency.size() == 3 &&
        data.brand is string &&
        data.model is string &&
        data.year is number &&
        data.year >= 1950 &&
        data.year <= 2030 &&
        data.fuelType is string &&
        data.transmission is string &&
        data.condition is string &&
        data.category is string &&
        data.country is string &&
        data.country.size() == 2 &&
        data.licensePlate is string &&
        data.licensePlate.size() >= 3 &&
        data.licensePlate.size() <= 15 &&
        data.userId == request.auth.uid &&
        data.createdAt is timestamp;
      }
      
      function checkVehicleLimit() {
        // Free users can have max 3 vehicles
        // This would need to be checked in the client or cloud function
        return true;
      }
    }
    
    // Chat conversations
    match /conversations/{conversationId} {
      // Doar participanții pot accesa conversația
      allow read: if isAuthenticated() && 
        (request.auth.uid in resource.data.participants);
      allow write: if isAuthenticated() && 
        (request.auth.uid in resource.data.participants);
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.participants;
      allow delete: if isAuthenticated() && 
        (request.auth.uid in resource.data.participants);
      
      // Messages subcollection
      match /messages/{messageId} {
        // Utilizatorii autentificați pot citi mesajele din conversațiile lor
        allow read: if isAuthenticated() && 
          (request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants);
        
        // Doar expeditorul poate crea mesajul
        allow create: if isAuthenticated() && 
          request.auth.uid == request.resource.data.senderId &&
          validateMessageData();
        
        // Oricine din conversație poate marca ca citit
        allow update: if isAuthenticated() && 
          (request.auth.uid == resource.data.receiverId || 
           request.auth.uid == resource.data.senderId) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']);
        
        // Doar expeditorul poate șterge propriile mesaje, sau oricine din conversație pentru clear chat
        allow delete: if isAuthenticated() && 
          (request.auth.uid == resource.data.senderId ||
           request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants);

        function validateMessageData() {
          let data = request.resource.data;
          return data.keys().hasAll(['senderId', 'receiverId', 'message', 'timestamp']) &&
            data.senderId == request.auth.uid &&
            data.message is string &&
            data.message.size() > 0 &&
            data.message.size() <= 1000 &&
            data.timestamp is timestamp &&
            data.receiverId is string &&
            data.receiverId != request.auth.uid;
        }
      }
    }
    
    // Reviews collection
    match /reviews/{reviewId} {
      allow read: if true; // Public read access
      allow create: if isValidUser() &&
                       validateReviewData() &&
                       !hasExistingReview();
      allow update, delete: if isValidUser() && 
                               isOwner(resource);
      
      function validateReviewData() {
        let data = request.resource.data;
        return data.keys().hasAll(['rating', 'comment', 'reviewerId', 'reviewedUserId', 'vehicleId', 'createdAt']) &&
               data.rating is number &&
               data.rating >= 1 &&
               data.rating <= 5 &&
               data.comment is string &&
               data.comment.size() <= 500 &&
               data.reviewerId == request.auth.uid &&
               data.reviewedUserId is string &&
               data.reviewedUserId != request.auth.uid &&
               data.vehicleId is string &&
               data.createdAt is timestamp;
      }
      
      function hasExistingReview() {
        // Check if user already reviewed this vehicle/user combination
        // This would need additional logic or cloud function
        return false;
      }
    }
    
    // Favorites collection
    match /favorites/{favoriteId} {
      allow read: if true; // Public read for favorite counts și notificări
      allow create: if isValidUser() &&
                       validateFavoriteData();
      allow write: if isValidUser() && 
                      request.auth.uid == request.resource.data.userId;
      allow delete: if isValidUser() && 
                       request.auth.uid == resource.data.userId;
      
      function validateFavoriteData() {
        let data = request.resource.data;
        return data.keys().hasAny(['vehicleId', 'itemId']) &&
               data.userId == request.auth.uid &&
               (data.vehicleId is string || data.itemId is string) &&
               data.createdAt is timestamp &&
               // Câmpuri pentru notificări
               (!data.keys().hasAny(['itemOwnerId']) || data.itemOwnerId is string) &&
               (!data.keys().hasAny(['itemTitle']) || data.itemTitle is string) &&
               (!data.keys().hasAny(['itemBrand']) || data.itemBrand is string);
      }
    }
    
    // User subscriptions
    match /subscriptions/{subscriptionId} {
      allow read, write: if isValidUser() && 
                            request.auth.uid == resource.data.userId;
      allow create: if isValidUser() &&
                       validateSubscriptionData();
      
      function validateSubscriptionData() {
        let data = request.resource.data;
        return data.keys().hasAll(['userId', 'plan', 'status', 'startDate', 'endDate']) &&
               data.userId == request.auth.uid &&
               data.plan in ['free', 'premium', 'business'] &&
               data.status in ['active', 'cancelled', 'expired'] &&
               data.startDate is timestamp &&
               data.endDate is timestamp;
      }
    }
    
    // Search history (private to user)
    match /searchHistory/{userId} {
      allow read, write: if isValidUser() && 
                            request.auth.uid == userId;
      
      match /searches/{searchId} {
        allow read, write: if isValidUser() && 
                              request.auth.uid == userId;
      }
    }
    
    // Analytics and statistics (read-only for users)
    match /analytics/{document=**} {
      allow read: if isValidUser();
      allow write: if false; // Only server-side writes
    }
    
    // Admin collection (admin only)
    match /admin/{document=**} {
      allow read, write: if isValidUser() && 
                            hasAdminRole();
    }
    
    // Reports collection
    match /reports/{reportId} {
      allow read: if isValidUser() && 
                     (isOwner(resource) || hasAdminRole());
      allow create: if isValidUser() &&
                       validateReportData();
      
      function validateReportData() {
        let data = request.resource.data;
        return data.keys().hasAll(['reporterId', 'reportedUserId', 'reason', 'timestamp']) &&
               data.reporterId == request.auth.uid &&
               data.reportedUserId is string &&
               data.reportedUserId != request.auth.uid &&
               data.reason is string &&
               data.reason.size() > 0 &&
               data.timestamp is timestamp;
      }
    }
    
    // Accessories collection
    match /accessories/{accessoryId} {
      allow read: if true; // Public read access
      allow create: if isValidUser() &&
                       validateAccessoryData();
      allow update, delete: if isValidUser() && 
                               isOwner(resource);
      
      function validateAccessoryData() {
        let data = request.resource.data;
        return data.keys().hasAll(['name', 'description', 'price', 'category', 'sellerId', 'createdAt']) &&
               data.name is string &&
               data.name.size() >= 3 &&
               data.name.size() <= 100 &&
               data.description is string &&
               data.description.size() <= 1000 &&
               data.price is number &&
               data.price > 0 &&
               data.category is string &&
               data.sellerId == request.auth.uid &&
               data.createdAt is timestamp;
      }
    }
    
    // Services collection
    match /services/{serviceId} {
      allow read: if true; // Public read access
      allow create: if isValidUser() &&
                       validateServiceData();
      allow update, delete: if isValidUser() && 
                               isOwner(resource);
      
      function validateServiceData() {
        let data = request.resource.data;
        return data.keys().hasAll(['name', 'description', 'priceRange', 'category', 'providerId', 'location', 'createdAt']) &&
               data.name is string &&
               data.name.size() >= 3 &&
               data.name.size() <= 100 &&
               data.description is string &&
               data.description.size() <= 1000 &&
               data.priceRange is string &&
               data.category is string &&
               data.providerId == request.auth.uid &&
               data.location is string &&
               data.createdAt is timestamp;
      }
    }
    
    // Transfer requests collection
    match /transfer_requests/{requestId} {
      allow read: if isValidUser() && 
                     (request.auth.uid == resource.data.fromUserId || 
                      request.auth.uid == resource.data.toUserId);
      allow create: if isValidUser() &&
                       validateTransferRequestData();
      allow update: if isValidUser() && 
                       (request.auth.uid == resource.data.fromUserId || 
                        request.auth.uid == resource.data.toUserId) &&
                       validateTransferRequestUpdate();
      
      function validateTransferRequestData() {
        let data = request.resource.data;
        return data.keys().hasAll(['vehicleId', 'fromUserId', 'toUserId', 'licensePlate', 'countryCode', 'status', 'createdAt']) &&
               data.vehicleId is string &&
               data.fromUserId is string &&
               data.toUserId == request.auth.uid &&
               data.licensePlate is string &&
               data.countryCode is string &&
               data.status == 'pending' &&
               data.createdAt is timestamp;
      }
      
      function validateTransferRequestUpdate() {
        let data = request.resource.data;
        return data.status in ['pending', 'accepted', 'rejected'] &&
               (resource.data.status == 'pending' || data.status == resource.data.status);
      }
    }
    
    // Notifications collection
    match /notifications/{notificationId} {
      allow read, update: if isValidUser() && 
                             request.auth.uid == resource.data.userId;
      allow create: if isValidUser() &&
                       validateNotificationData();
      allow delete: if isValidUser() && 
                       request.auth.uid == resource.data.userId;
      
      function validateNotificationData() {
        let data = request.resource.data;
        return data.keys().hasAll(['userId', 'title', 'message', 'type', 'isRead', 'createdAt']) &&
               data.userId is string &&
               data.title is string &&
               data.title.size() <= 100 &&
               data.message is string &&
               data.message.size() <= 500 &&
               data.type in ['chat', 'transfer', 'review', 'system'] &&
               data.isRead is bool &&
               data.createdAt is timestamp;
      }
    }
    
    // Cars collection - new marketplace functionality
    match /cars/{carId} {
      allow read, write: if true; // Temporary: Allow all access for debugging
    }

    // Marketplace collection
    match /marketplace/{itemId} {
      allow read: if true; // Public read access for browsing
      allow create: if isAuthenticated(); // Simplified: allow any authenticated user to create
      allow update: if isAuthenticated(); // Temporary: allow all authenticated users to update
      allow delete: if isAuthenticated() && 
                       request.auth.uid == resource.data.sellerId;

      function validateMarketplaceItemData() {
        let data = request.resource.data;
        let isValidBasic = data.keys().hasAll(['title', 'description', 'price', 'currency', 'type', 'sellerId', 'sellerName', 'createdAt', 'isActive']) &&
               data.title is string &&
               data.title.size() >= 3 &&
               data.title.size() <= 100 &&
               data.description is string &&
               data.description.size() <= 1000 &&
               data.price is number &&
               data.price > 0 &&
               data.currency is string &&
               data.currency.size() == 3 &&
               data.type in ['car', 'accessory', 'service'] &&
               data.sellerId == request.auth.uid &&
               data.sellerName is string &&
               data.createdAt is timestamp &&
               data.isActive is bool;
        
        // Additional validation for car type
        let isValidCar = data.type != 'car' || (
          data.details is map &&
          data.details.keys().hasAll(['country', 'plateNumber', 'brand', 'model']) &&
          data.details.country is string &&
          data.details.country.size() >= 2 &&
          data.details.plateNumber is string &&
          data.details.plateNumber.size() >= 3 &&
          data.details.plateNumber.size() <= 15 &&
          data.details.brand is string &&
          data.details.brand.size() >= 1 &&
          data.details.model is string &&
          data.details.model.size() >= 1 &&
          // Optional car fields validation
          (!data.details.keys().hasAny(['year']) || data.details.year is number) &&
          (!data.details.keys().hasAny(['mileage']) || data.details.mileage is number) &&
          (!data.details.keys().hasAny(['power']) || data.details.power is number) &&
          (!data.details.keys().hasAny(['previousOwners']) || data.details.previousOwners is number) &&
          (!data.details.keys().hasAny(['fuelType']) || data.details.fuelType is string) &&
          (!data.details.keys().hasAny(['transmission']) || data.details.transmission is string) &&
          (!data.details.keys().hasAny(['bodyType']) || data.details.bodyType is string) &&
          (!data.details.keys().hasAny(['color']) || data.details.color is string) &&
          (!data.details.keys().hasAny(['doors']) || data.details.doors is string) &&
          (!data.details.keys().hasAny(['condition']) || data.details.condition is string) &&
          (!data.details.keys().hasAny(['urgencyLevel']) || data.details.urgencyLevel is string) &&
          // Boolean fields validation
          (!data.details.keys().hasAny(['isForSale']) || data.details.isForSale is bool) &&
          (!data.details.keys().hasAny(['isPriceNegotiable']) || data.details.isPriceNegotiable is bool) &&
          (!data.details.keys().hasAny(['isVisibleInMarketplace']) || data.details.isVisibleInMarketplace is bool) &&
          (!data.details.keys().hasAny(['allowContactFromBuyers']) || data.details.allowContactFromBuyers is bool) &&
          (!data.details.keys().hasAny(['hasServiceHistory']) || data.details.hasServiceHistory is bool) &&
          (!data.details.keys().hasAny(['hasAccidentHistory']) || data.details.hasAccidentHistory is bool) &&
          // Equipment boolean fields
          (!data.details.keys().hasAny(['hasABS']) || data.details.hasABS is bool) &&
          (!data.details.keys().hasAny(['hasESP']) || data.details.hasESP is bool) &&
          (!data.details.keys().hasAny(['hasAirbags']) || data.details.hasAirbags is bool) &&
          (!data.details.keys().hasAny(['hasAlarm']) || data.details.hasAlarm is bool) &&
          (!data.details.keys().hasAny(['hasAirConditioning']) || data.details.hasAirConditioning is bool) &&
          (!data.details.keys().hasAny(['hasHeatedSeats']) || data.details.hasHeatedSeats is bool) &&
          (!data.details.keys().hasAny(['hasNavigation']) || data.details.hasNavigation is bool) &&
          (!data.details.keys().hasAny(['hasBluetooth']) || data.details.hasBluetooth is bool) &&
          (!data.details.keys().hasAny(['hasUSB']) || data.details.hasUSB is bool) &&
          (!data.details.keys().hasAny(['hasLeatherSteering']) || data.details.hasLeatherSteering is bool) &&
          (!data.details.keys().hasAny(['hasAlloyWheels']) || data.details.hasAlloyWheels is bool) &&
          (!data.details.keys().hasAny(['hasSunroof']) || data.details.hasSunroof is bool) &&
          (!data.details.keys().hasAny(['hasXenonLights']) || data.details.hasXenonLights is bool) &&
          (!data.details.keys().hasAny(['hasElectricMirrors']) || data.details.hasElectricMirrors is bool)
        );
        
        return isValidBasic && isValidCar;
      }

      // Reviews subcollection for marketplace items
      match /reviews/{reviewId} {
        allow read: if true; // Public read access
        allow create: if isAuthenticated();
        allow update, delete: if isAuthenticated() && 
                                 request.auth.uid == resource.data.reviewerId;
      }
    }

    // Transactions collection - monetization system
    match /transactions/{transactionId} {
      allow read: if isAuthenticated() && 
                     request.auth.uid == resource.data.userId;
      allow create: if isAuthenticated() && 
                       request.auth.uid == resource.data.userId &&
                       validateTransactionData();
      allow update: if hasAdminRole() || 
                       (isAuthenticated() && 
                        request.auth.uid == resource.data.userId &&
                        onlyAllowedTransactionUpdates());
      allow delete: if hasAdminRole();

      function validateTransactionData() {
        let data = request.resource.data;
        return data.keys().hasAll(['userId', 'type', 'amount', 'status', 'transactionId', 'createdAt']) &&
               data.userId == request.auth.uid &&
               data.type in ['subscription', 'boost', 'unblock'] &&
               data.amount is number &&
               data.amount > 0 &&
               data.status in ['pending', 'completed', 'failed', 'refunded'] &&
               data.transactionId is string &&
               data.transactionId.size() > 0 &&
               data.createdAt is timestamp;
      }

      function onlyAllowedTransactionUpdates() {
        let allowedFields = ['status', 'metadata'];
        return request.resource.data.diff(resource.data).affectedKeys()
                 .hasOnly(allowedFields);
      }
    }

    // Subscriptions collection
    match /subscriptions/{subscriptionId} {
      allow read: if isAuthenticated() && 
                     request.auth.uid == resource.data.userId;
      allow create: if isAuthenticated() && 
                       request.auth.uid == resource.data.userId &&
                       validateSubscriptionData();
      allow update: if isAuthenticated() && 
                       request.auth.uid == resource.data.userId &&
                       onlyAllowedSubscriptionUpdates();
      allow delete: if hasAdminRole();

      function validateSubscriptionData() {
        let data = request.resource.data;
        return data.keys().hasAll(['userId', 'type', 'startDate', 'endDate', 'isActive', 'transactionId']) &&
               data.userId == request.auth.uid &&
               data.type in ['monthly', 'annual', 'lifetime'] &&
               data.startDate is timestamp &&
               data.endDate is timestamp &&
               data.isActive is bool &&
               data.transactionId is string;
      }

      function onlyAllowedSubscriptionUpdates() {
        let allowedFields = ['isActive', 'endDate'];
        return request.resource.data.diff(resource.data).affectedKeys()
                 .hasOnly(allowedFields);
      }
    }

    // Boosts collection
    match /boosts/{boostId} {
      allow read: if true; // Public read for marketplace display
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.userId &&
                       validateBoostData();
      allow update: if isAuthenticated() && 
                       request.auth.uid == resource.data.userId &&
                       onlyAllowedBoostUpdates();
      allow delete: if isAuthenticated() && 
                       (request.auth.uid == resource.data.userId || hasAdminRole());

      function validateBoostData() {
        let data = request.resource.data;
        let hasRequiredFields = data.keys().hasAll(['userId', 'itemId', 'type', 'price', 'isActive']) &&
               data.userId == request.auth.uid &&
               data.type in [
                 // Legacy boost types
                 'renewAd', 'coloredFrame', 'topBrandModel', 'topRecommended', 'pushNotification', 'localBoost', 'labelTags', 'animatedBorder',
                 // New visual boost types
                 'new_badge', 'discount_badge', 'negotiable_badge', 'delivery_badge', 'popular_badge',
                 'colored_border', 'animated_border', 'glow_effect',
                 'pulsing_card', 'shimmer_label', 'bounce_load',
                 'triangle_corner', 'orbital_star', 'hologram_effect', 'light_ray',
                 'floating_badge', 'torn_sticker', 'handwritten_sticker', 'renewal'
               ] &&
               data.isActive is bool &&
               data.price is number && data.price >= 0.0;

        // Optional fields validation
        let hasValidOptionalFields = 
               (!data.keys().hasAny(['currency']) || data.currency is string) &&
               (!data.keys().hasAny(['duration']) || data.duration is number) &&
               (!data.keys().hasAny(['playStoreId']) || data.playStoreId is string) &&
               (!data.keys().hasAny(['createdAt']) || data.createdAt is timestamp) &&
               (!data.keys().hasAny(['expiresAt']) || data.expiresAt is timestamp) &&
               (!data.keys().hasAny(['toggledAt']) || data.toggledAt is timestamp) &&
               (!data.keys().hasAny(['metadata']) || data.metadata is map);

        return hasRequiredFields && hasValidOptionalFields;
      }

      function onlyAllowedBoostUpdates() {
        let allowedFields = ['isActive', 'endDate', 'toggledAt', 'expiresAt'];
        return request.resource.data.diff(resource.data).affectedKeys()
                 .hasOnly(allowedFields);
      }
    }

    // User blocks collection
    match /user_blocks/{blockId} {
      allow read: if isAuthenticated() && 
                     request.auth.uid == resource.data.userId;
      allow create: if hasAdminRole() || 
                       validateUserBlockData();
      allow update: if hasAdminRole() || 
                       (isAuthenticated() && 
                        request.auth.uid == resource.data.userId &&
                        onlyAllowedBlockUpdates());
      allow delete: if hasAdminRole();

      function validateUserBlockData() {
        let data = request.resource.data;
        return data.keys().hasAll(['userId', 'reason', 'startDate', 'endDate', 'isActive', 'reportCount']) &&
               data.userId is string &&
               data.reason is string &&
               data.startDate is timestamp &&
               data.endDate is timestamp &&
               data.isActive is bool &&
               data.reportCount is number &&
               data.reportCount >= 3;
      }

      function onlyAllowedBlockUpdates() {
        let allowedFields = ['isActive', 'endDate'];
        return request.resource.data.diff(resource.data).affectedKeys()
                 .hasOnly(allowedFields);
      }
    }

    // Analytics collections
    match /marketplace_items/{itemId} {
      allow read: if true; // Public read for marketplace items
      allow write: if isAuthenticated() && 
                      request.auth.uid == resource.data.sellerId;
    }

    match /user_analytics/{userId} {
      allow read, write: if isAuthenticated() && 
                            request.auth.uid == userId;
      
      match /daily_views/{date} {
        allow read, write: if isAuthenticated() && 
                              request.auth.uid == userId;
      }
    }

    match /item_views/{viewId} {
      allow read: if isAuthenticated();
      allow create: if true; // Allow anonymous view tracking
    }

    match /marketplace_activity/{activityId} {
      allow read: if isAuthenticated() && 
                     request.auth.uid == resource.data.userId;
      allow create: if true; // Allow system to create activities
    }

    match /profile_views/{viewId} {
      allow read: if isAuthenticated();
      allow create: if true; // Allow anonymous profile view tracking
    }

    // Price history collection - pentru monitorizarea prețurilor
    match /price_history/{historyId} {
      allow read: if true; // Public read pentru afișarea istoricului
      allow write: if false; // Doar server-ul poate scrie
    }

    // Pending notifications collection - pentru serverul de notificări
    match /pending_notifications/{notificationId} {
      allow create: if isAuthenticated(); // Utilizatorii pot crea notificări pending
      allow read, update, delete: if false; // Doar server-ul cu service account poate citi/actualiza/șterge
    }

    // Scheduled tasks collection - pentru task-urile programate
    match /scheduled_tasks/{taskId} {
      allow read, write: if false; // Doar server-ul cu service account
    }

    // FCM Tokens collection - pentru notificările push
    match /fcm_tokens/{tokenId} {
      allow read: if isAuthenticated() && 
                     request.auth.uid == resource.data.userId;
      allow write: if isAuthenticated() && 
                      request.auth.uid == request.resource.data.userId;
      allow create: if isAuthenticated() && 
                       validateFCMTokenData();
      allow delete: if isAuthenticated() && 
                       request.auth.uid == resource.data.userId;

      function validateFCMTokenData() {
        let data = request.resource.data;
        return data.keys().hasAll(['userId', 'token', 'createdAt']) &&
               data.userId == request.auth.uid &&
               data.token is string &&
               data.token.size() > 0 &&
               data.createdAt is timestamp;
      }
    }
  }
}